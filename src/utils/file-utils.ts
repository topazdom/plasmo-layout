import { dirname, basename, join, extname, relative } from 'node:path'
import fs from 'fs-extra'
import { glob } from 'glob'
import micromatch from 'micromatch'
import type { ResolvedConfig } from '../types/index.js'

/**
 * Generated file header comment for tracking
 */
export const GENERATED_HEADER = '<!-- GENERATED BY PLASMO-LAYOUT - DO NOT EDIT MANUALLY -->'

/**
 * Check if a file was generated by plasmo-layout
 * @param filePath - Path to the file to check
 * @returns true if file contains the generated header
 */
export async function isGeneratedFile(filePath: string): Promise<boolean> {
  try {
    if (!(await fs.pathExists(filePath))) {
      return false
    }
    const content = await fs.readFile(filePath, 'utf-8')
    return content.includes(GENERATED_HEADER)
  } catch {
    return false
  }
}

/**
 * Get all files matching include patterns and not matching exclude patterns
 * @param config - Resolved configuration
 * @returns Array of absolute file paths
 */
export async function getMatchingFiles(config: ResolvedConfig): Promise<string[]> {
  const { include, exclude, rootDir } = config

  // Get all files matching include patterns
  const files = await glob(include, {
    cwd: rootDir,
    absolute: true,
    nodir: true,
    ignore: exclude,
  })

  return files
}

/**
 * Check if a file path matches exclude patterns
 * @param filePath - File path to check (relative or absolute)
 * @param excludePatterns - Array of glob patterns to exclude
 * @param rootDir - Project root directory
 * @returns true if file should be excluded
 */
export function isExcluded(filePath: string, excludePatterns: string[], rootDir: string): boolean {
  const relativePath = filePath.startsWith(rootDir) ? relative(rootDir, filePath) : filePath

  return micromatch.isMatch(relativePath, excludePatterns)
}

/**
 * Convert component file path to output HTML file path following Plasmo conventions
 *
 * Rules:
 * - src/popup/index.tsx -> src/popup/popup.html
 * - src/popup.tsx -> src/popup.html
 * - src/options/index.tsx -> src/options/options.html
 * - src/tabs/settings.tsx -> src/tabs/settings.html
 *
 * @param componentPath - Absolute path to the component file
 * @returns Absolute path to the output HTML file
 */
export function getOutputHtmlPath(componentPath: string): string {
  const dir = dirname(componentPath)
  const base = basename(componentPath)
  const nameWithoutExt = basename(base, extname(base))

  // If the file is named index.tsx/jsx, use the parent directory name
  if (nameWithoutExt === 'index') {
    const parentDirName = basename(dir)
    return join(dir, `${parentDirName}.html`)
  }

  // Otherwise, use the file name
  return join(dir, `${nameWithoutExt}.html`)
}

/**
 * Resolve a layout path (dot notation) to an absolute file path
 * Checks for files with engine-specific extensions in fallback order
 *
 * @param layoutPath - Layout path in dot notation (e.g., 'tabs.onboarding')
 * @param config - Resolved configuration
 * @returns Absolute path to the layout file and the engine type, or undefined if not found
 */
export async function resolveLayoutPath(
  layoutPath: string,
  config: ResolvedConfig,
): Promise<{ path: string; engineType: string } | undefined> {
  // Convert dot notation to path segments
  const segments = layoutPath.split('.')
  const layoutDir = join(config.layoutsDirAbsolute, ...segments.slice(0, -1))
  const layoutName = segments[segments.length - 1]

  // Get extension fallback chain based on configured engine
  const engineOrder: Array<'jsx' | 'edge' | 'custom'> = [config.engine as 'jsx' | 'edge' | 'custom']

  // Add other engines as fallback
  if (config.engine !== 'jsx') engineOrder.push('jsx')
  if (config.engine !== 'edge') engineOrder.push('edge')
  if (config.engine !== 'custom') engineOrder.push('custom')

  // Try each engine's extensions in order
  for (const engineType of engineOrder) {
    const extensions = config.extensionFallback[engineType] || []

    for (const ext of extensions) {
      // Try direct file path
      const directPath = join(layoutDir, `${layoutName}${ext}`)
      if (await fs.pathExists(directPath)) {
        return { path: directPath, engineType }
      }

      // Try index file in directory
      const indexPath = join(layoutDir, layoutName, `index${ext}`)
      if (await fs.pathExists(indexPath)) {
        return { path: indexPath, engineType }
      }
    }
  }

  // Also try the full path as a directory with index files
  const fullLayoutDir = join(config.layoutsDirAbsolute, ...segments)
  for (const engineType of engineOrder) {
    const extensions = config.extensionFallback[engineType] || []

    for (const ext of extensions) {
      const indexPath = join(fullLayoutDir, `index${ext}`)
      if (await fs.pathExists(indexPath)) {
        return { path: indexPath, engineType }
      }
    }
  }

  return undefined
}

/**
 * Write generated HTML content to file with tracking header
 * @param outputPath - Path to write the HTML file
 * @param htmlContent - HTML content to write
 */
export async function writeGeneratedHtml(outputPath: string, htmlContent: string): Promise<void> {
  // Ensure the output directory exists
  await fs.ensureDir(dirname(outputPath))

  // Prepend the generated header
  const contentWithHeader = `${GENERATED_HEADER}\n${htmlContent}`

  await fs.writeFile(outputPath, contentWithHeader, 'utf-8')
}

/**
 * Find all generated HTML files in the project
 * @param config - Resolved configuration
 * @returns Array of paths to generated HTML files
 */
export async function findGeneratedFiles(config: ResolvedConfig): Promise<string[]> {
  const htmlFiles = await glob('**/*.html', {
    cwd: config.rootDir,
    absolute: true,
    nodir: true,
    ignore: config.exclude,
  })

  const generatedFiles: string[] = []

  for (const filePath of htmlFiles) {
    if (await isGeneratedFile(filePath)) {
      generatedFiles.push(filePath)
    }
  }

  return generatedFiles
}

/**
 * Delete a generated file
 * @param filePath - Path to the file to delete
 * @returns true if file was deleted, false if it didn't exist or wasn't generated
 */
export async function deleteGeneratedFile(filePath: string): Promise<boolean> {
  if (!(await isGeneratedFile(filePath))) {
    return false
  }

  await fs.remove(filePath)
  return true
}

/**
 * Get relative path from root directory for display
 * @param absolutePath - Absolute file path
 * @param rootDir - Project root directory
 * @returns Relative path string
 */
export function getRelativePath(absolutePath: string, rootDir: string): string {
  return relative(rootDir, absolutePath)
}
